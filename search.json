[{"path":"https://eddieyang1222.github.io/INClock/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 INClock authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://eddieyang1222.github.io/INClock/articles/vignette_1_basic_workflow.html","id":"vignette-info","dir":"Articles","previous_headings":"","what":"Vignette Info","title":"Vignette 1: Basic workflow of INClock","text":"vignette depicts basic workflow INClock generates dispersion parameters cell type / age group. Examples downstream analyses can found vignettes.","code":"library(\"INClock\")"},{"path":"https://eddieyang1222.github.io/INClock/articles/vignette_1_basic_workflow.html","id":"prepare-the-test-data","dir":"Articles","previous_headings":"","what":"Prepare the test data","title":"Vignette 1: Basic workflow of INClock","text":"use single-cell RNA sequencing data Tabula Muris Senis test data. Specifically, concerns bone marrow cells mouse different ages. original dataset large demonstration, take subset relevant cell types age groups, includes one younger (3 months) one older (30 months) age groups, well several stem cell types, hematopoietic precursor cell (HSC). dataset loaded TabulaMurisSenisData, already integrated package test purposes.","code":"# Load test data from Tabula Muris Senis tms_marrow <- TabulaMurisSenisData::TabulaMurisSenisDroplet(tissues = \"Marrow\") tms_marrow_counts <- tms_marrow$Marrow@assays@data$counts rownames(tms_marrow_counts) <- rownames(tms_marrow$Marrow) colnames(tms_marrow_counts) <- colnames(tms_marrow$Marrow) tms_marrow_counts <- as(tms_marrow_counts, \"dgCMatrix\")  # Subset age groups and cell types subset_ages <- which(tms_marrow$Marrow$age %in% c(\"3m\", \"30m\")) subset_cell_types <- which(tms_marrow$Marrow$cell_ontology_class %in% c(   \"hematopoietic precursor cell\", \"megakaryocyte-erythroid progenitor cell\",   \"precursor B cell\" )) tms_marrow_counts <- tms_marrow_counts[, intersect(subset_ages, subset_cell_types)]"},{"path":"https://eddieyang1222.github.io/INClock/articles/vignette_1_basic_workflow.html","id":"compute-the-manifold","dir":"Articles","previous_headings":"","what":"Compute the manifold","title":"Vignette 1: Basic workflow of INClock","text":"can simply call compute_manifold() compute manifold matrix test data. function requires one input files: Gene expression count matrix (Gene Cell) (counts) matrix either matrix dgCMatrix format, required dependent packages SAVER Seurat. running, need specify method use, either 'SAVER' 'neighbor'. 'SAVER' selected, following customizable options: Number CPU cores use. Default 1. (ncores) 'neighbor' selected, following customizable options: Number features finding variable features. Default 3000. (nfeatures) Number dimensions finding nearest neighbors. Default 20. (dims) Number neighbors output. Default 20. (neighbors) number features dimensions typically don’t affect quality manifold much. number neighbors used, however, can somewhat affect. facilitate optimal selection number neighbors, recommended go Vignette 3. previous tests, datasets less 100,000 cells typically optimal number neighbors around 20 30. output manifold matrix dimensions original count matrix, course sparse . cautious step use relatively large memory.","code":"# Compute the manifold with SAVER tms_marrow_manifold_saver <- compute_manifold(tms_marrow_counts, method = \"SAVER\")  # Compute the manifold with neighbor-based method tms_marrow_manifold_neighbor <- compute_manifold(tms_marrow_counts, method = \"neighbor\")"},{"path":"https://eddieyang1222.github.io/INClock/articles/vignette_1_basic_workflow.html","id":"estimate-dispersion-parameters","dir":"Articles","previous_headings":"","what":"Estimate dispersion parameters","title":"Vignette 1: Basic workflow of INClock","text":"Now manifold computed, can call estimate_dispersion estimate dispersion parameters. function takes following inputs: Gene expression count matrix (Gene Cell) (counts) Manifold matrix (manifold) vector cell types cell dataset belongs (cell.types) vector age groups cell dataset belongs (ages) also necessary choose variance model estimation, can 'cCV' (constant Coefficient Variation), 'cFF' (constant Fano Factor), 'cVar' (constant Variance). recommend using constant CV, also default model used. Besides, options customize process: Number CPU cores use. Default 1. (ncores) Cell size normalization factors. Default uses mean library size normalization. (size.factor) vector cell types labels used estimation process. (cell.types..use) vector age group labels used estimation process. (ages..use) Minimum number cells cell type / age group. Groups fewer cells number skipped. Default 10. (cell.types.cutoff) Finally, able generate list object containing multiple dataframes, corresponds cell type. dataframe, first column genes, later ones dispersion parameter values age group.","code":"# Create cell type and age labels tms_marrow_cell_types <- tms_marrow$Marrow$cell_ontology_class[intersect(subset_ages, subset_cell_types)] tms_marrow_ages <- tms_marrow$Marrow$age[intersect(subset_ages, subset_cell_types)]  # Estimate the dispersion parameters using constant CV tms_marrow_dispersions <- estimate_dispersion(tms_marrow_counts, tms_marrow_manifold_neighbor,   tms_marrow_cell_types, tms_marrow_ages,   model = \"cCV\", ncores = 2 )"},{"path":"https://eddieyang1222.github.io/INClock/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yilin Yang. Author, maintainer.","code":""},{"path":"https://eddieyang1222.github.io/INClock/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yang Y (2024). INClock: Intrinsic Noise based cellular aging Clock. R package version 0.0.1, https://eddieyang1222.github.io/INClock/.","code":"@Manual{,   title = {INClock: Intrinsic Noise based cellular aging Clock},   author = {Yilin Yang},   year = {2024},   note = {R package version 0.0.1},   url = {https://eddieyang1222.github.io/INClock/}, }"},{"path":"https://eddieyang1222.github.io/INClock/index.html","id":"inclock","dir":"","previous_headings":"","what":"Intrinsic Noise based cellular aging Clock","title":"Intrinsic Noise based cellular aging Clock","text":"INClock (Intrinsic Noise based cellular aging Clock) provides robust scalable measure cellular aging senescence estimating intrinsic transcriptional noise single-cell RNA sequencing data. using package, capable : Compute manifold approximates true state cells using two methods: Decompose cellular variation using SAVER Average across k nearest neighbors (efficient) Estimate dispersion parameters cell types / age groups using updated version SAVER","code":""},{"path":"https://eddieyang1222.github.io/INClock/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Intrinsic Noise based cellular aging Clock","text":"recent version INClock can installed GitHub : R version > 4.2.0 recommended.","code":"# install.packages(\"devtools\") devtools::install_github(\"EddieYang1222/INClock\")"},{"path":"https://eddieyang1222.github.io/INClock/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Intrinsic Noise based cellular aging Clock","text":"questions regarding package, please contact Yilin Yang (yang1222@wharton.upenn.edu) Nancy Zhang (nzh@wharton.upenn.edu).","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/compute_manifold.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a manifold for gene expression count data — compute_manifold","title":"Compute a manifold for gene expression count data — compute_manifold","text":"Compute manifold gene expression count data","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/compute_manifold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a manifold for gene expression count data — compute_manifold","text":"","code":"compute_manifold(   counts,   method = \"neighbor\",   preprocess = TRUE,   ncores = 1,   nfeatures = 3000,   dims = 20,   neighbors = 20 )"},{"path":"https://eddieyang1222.github.io/INClock/reference/compute_manifold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a manifold for gene expression count data — compute_manifold","text":"counts expression count matrix. rows correspond genes columns correspond cells. can sparse. method Method estimating manifold. Can either \"SAVER\", uses SAVER recover true expression, 'neighbor', uses nearest neighbors approximate true expression preprocess Whether expression count matrix preprocessed, genes zero counts removed. Default TRUE. ncores Number cores use. Default 1. (SAVER ) nfeatures Number features use FindVariableFeatures. Default 3000. (Neighbor-based ) dims Number dimensions nearest neighbors. Default 20.(Neighbor-based ) neighbors Number neighbors output. Default 20. (Neighbor-based )","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/compute_manifold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a manifold for gene expression count data — compute_manifold","text":"matrix estimated gene expressions.","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/compute_manifold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a manifold for gene expression count data — compute_manifold","text":"","code":"# Load test data from Tabula Muris Senis tms_marrow <- TabulaMurisSenisData::TabulaMurisSenisDroplet(tissues = \"Marrow\") #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> require(“rhdf5”) #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> require(“S4Vectors”) #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache tms_marrow_counts <- tms_marrow$Marrow@assays@data$counts rownames(tms_marrow_counts) <- rownames(tms_marrow$Marrow) colnames(tms_marrow_counts) <- colnames(tms_marrow$Marrow) tms_marrow_counts <- as(tms_marrow_counts, \"dgCMatrix\")  # Subset age groups and cell types subset_ages <- which(tms_marrow$Marrow$age %in% c(\"3m\", \"30m\")) subset_cell_types <- which(tms_marrow$Marrow$cell_ontology_class %in% c(   \"hematopoietic precursor cell\", \"megakaryocyte-erythroid progenitor cell\",   \"precursor B cell\" )) tms_marrow_counts <- tms_marrow_counts[, intersect(subset_ages, subset_cell_types)]  # Compute the manifold using both methods tms_marrow_manifold_saver <- compute_manifold(tms_marrow_counts, method = \"SAVER\") #> Starting manifold computation... #> The initial matrix size is 20138 genes and 1980 cells. #> After removing genes with zero counts, the new matrix size is 14812 genes and 1980 cells. #> Estimating the manifold using the SAVER method... #> 14812 genes, 1980 cells #> Running SAVER with 1 worker(s) #> Calculating predictions for 14812 genes using 6619 genes and 1980 cells... #> Start time: 2024-09-02 06:30:28.708834 #> Estimating finish time... #> Finished 8/14812 genes. Approximate finish time: 2024-09-02 06:48:09.368541 #> Calculating max cor cutoff... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:14:58.207338 #> Calculating lambda coefficients... #> Finished 237/14812 genes. Approximate finish time: 2024-09-02 07:17:17.701333 #> Predicting remaining genes... #> Finished 3881/14812 genes. Approximate finish time: 2024-09-02 07:50:25.638343 #> Predicting remaining genes... #> Done! #> Finish time: 2024-09-02 07:48:04.516227 #> Total time: 1.29328 hours #> Finished computing manifold using SAVER. Time taken: 4658.53 seconds. tms_marrow_manifold_neighbor <- compute_manifold(tms_marrow_counts, method = \"neighbor\") #> Starting manifold computation... #> The initial matrix size is 20138 genes and 1980 cells. #> After removing genes with zero counts, the new matrix size is 14812 genes and 1980 cells. #> Estimating the manifold using the neighbor-based method... #> Normalizing layer: counts #> Finding variable features for layer counts #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Ly6e, Bst2, Lgals1, Eef1g, Tspan13, Hspe1, Irf8, Tcf4, Fyb, Ctss  #> \t   Gas5, Selplg, Rnase6, Crip1, Siglech, Dnajc7, Pld4, Tsc22d1, Cnp, Npm1  #> \t   Cd7, Hsp90ab1, Tmsb10, Ly86, Cox6a2, Nme2, Bmyc, Ctsl, Pafah1b3, Ly6d  #> Negative:  Pglyrp1, S100a9, S100a8, Camp, Ngp, 1100001G20Rik, Hp, Lcn2, Cebpe, Chi3l3  #> \t   Anxa1, Clec4a2, Fcnb, Trem3, Dstn, Lyz2, Serpinb1a, Lyz1, Lrg1, Cd63  #> \t   Gsr, 1810033B17Rik, Sepx1, Cd177, Hmgn2, Mgst1, Arhgdib, Ltf, Glrx, Anxa3  #> PC_ 2  #> Positive:  Ptma, Stmn1, Cks1b, Hmgb1, Hist1h2ao, Cks2, Atpif1, Top2a, Cmtm7, Tuba1b  #> \t   H2afx, Birc5, Cdca8, Plac8, Hist1h2ae, Mki67, Rps27l, Spc24, Smc2, Gpx1  #> \t   Hmgb3, Ran, Tpx2, Lmnb1, Cdca3, Ybx1, Igfbp4, Ccna2, Eif5a, Myb  #> Negative:  Ccl5, Gimap4, Cd3d, Ms4a4b, Cd3g, Ltb, Shisa5, AW112010, Gimap3, Thy1  #> \t   Cd2, Lck, Ctsw, Gimap6, Ms4a6b, Cd3e, Skap1, Gimap7, Il2rb, Sh2d1a  #> \t   Xcl1, Lime1, Fam189b, Tmsb10, Klrk1, Arl4c, Txk, Zap70, Cd160, Bcl2  #> PC_ 3  #> Positive:  Ctla2a, Nkg7, AW112010, Ccnd2, Gpr56, Ccl5, Mif, Gimap4, Cd3d, Cd3g  #> \t   Ms4a4b, Rab38, Cd27, Lck, Bcl2, Rps2, Muc13, Lat, Klk8, Ltb  #> \t   Angpt1, Gimap3, Ms4a6b, Nrgn, Thy1, Serpina3g, Pdcd4, Rpl22l1, Gata2, Tspan4  #> Negative:  Grn, Ctsh, Siglech, Pld4, Rnase6, Mpeg1, Lair1, Ctsl, Cybasc3, Unc93b1  #> \t   Ctsb, Cox6a2, Nucb2, Ppfia4, Irf8, Ly86, Upb1, Tcf4, 2210020M01Rik, Ccr9  #> \t   Clec12a, Psap, Ly6d, Pltp, Runx2, Bst2, Spib, Cd300c, Atp1b1, Ccnd1  #> PC_ 4  #> Positive:  Ptma, Actg1, Rps2, Rpl22l1, Ldha, Ybx1, Nop10, Gpi1, Mif, Arhgdib  #> \t   Npm1, Rps15a-ps4, Pgam1, Nme2, Snrpf, Igfbp4, C1qbp, Impdh2, Tpi1, Cd34  #> \t   Gar1, Nhp2, Hspa8, Emb, Set, Cdca7, Pebp1, Cdk4, Hsp90ab1, Srm  #> Negative:  Gypa, Slc4a1, Rhd, Trim10, Tspan33, Beta-s, Tspo2, Snca, Rhag, Epb4.2  #> \t   Cldn13, Alas2, Ctse, Fech, Slc25a37, Isg20, Mgst3, Kel, Car2, Hmbs  #> \t   Hbb-b2, Blvrb, Fam55b, Ermap, Hemgn, Hbq1b, Cpox, Slc43a1, Apol11b, Dhrs11  #> PC_ 5  #> Positive:  Top2a, Tubb5, H2afx, Prc1, Nusap1, Racgap1, Cenpf, Cenpe, Kif11, Smc4  #> \t   Tpx2, Kif22, Kif23, Birc5, Ccna2, Aurkb, Tuba1b, Hist1h2ae, Mis18bp1, Cdca8  #> \t   Ube2s, Nek2, Ube2c, Cdca3, Hmmr, Kif20b, Spc24, Cks1b, Mki67, Cep55  #> Negative:  Sdpr, Pf4, Mpl, Rab27b, Gng11, Itga2b, Treml1, Gp9, Mmrn1, Esam  #> \t   Gp1bb, Gp5, Gucy1a3, Vwf, Fhl1, Rbpms2, Dusp3, Selp, Cttn, Mrvi1  #> \t   Clu, Tbxas1, Arhgap6, Ifitm3, Trpc6, Ptrf, F2rl2, Pbx1, Myct1, Gucy1b3  #> Computing nearest neighbors #> Only one graph name supplied, storing nearest-neighbor graph only #> [1] \"Successfully extracted the nearest neighbors. Estimation procedure is starting.\" #> Finished computing manifold using the neighbor-based method. Time taken: 7.73 seconds."},{"path":"https://eddieyang1222.github.io/INClock/reference/estimate_dispersion.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate dispersion parameters — estimate_dispersion","title":"Estimate dispersion parameters — estimate_dispersion","text":"Estimate dispersion parameters","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/estimate_dispersion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate dispersion parameters — estimate_dispersion","text":"","code":"estimate_dispersion(   counts,   manifold,   cell.types,   ages,   model = \"cCV\",   preprocess = TRUE,   ncores = 1,   size.factor = NULL,   cell.types.to.use = NULL,   ages.to.use = NULL,   cell.types.cutoff = 10 )"},{"path":"https://eddieyang1222.github.io/INClock/reference/estimate_dispersion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate dispersion parameters — estimate_dispersion","text":"counts expression count matrix. rows correspond genes columns correspond cells. can sparse. manifold computed manifold compute_manifold. matrix dimension counts. cell.types vector length columns counts. value string corresponding cell type cell counts. ages vector length columns counts. value string corresponding age group cell counts. model Model used estimating dispersion parameters. Can either \"cCV\" (constant CV), \"cFF\" (constant Fano factor), \"cVar\" (constant variance). preprocess Whether expression count matrix preprocessed, genes zero counts removed. Default TRUE. ncores Number cores use. Default 1. size.factor vector cell size normalization factors. Default uses mean library size normalization. cell.types..use vector unique cell types used estimation process. Default cell types. ages..use vector unique age groups used estimation process. Default age groups. cell.types.cutoff Minimum number cells cell type * age group. Default 10.","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/estimate_dispersion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate dispersion parameters — estimate_dispersion","text":"named list dispersion parameters. element table dispersion parameters cell type. columns table contain dispersion parameters age group.","code":""},{"path":"https://eddieyang1222.github.io/INClock/reference/estimate_dispersion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate dispersion parameters — estimate_dispersion","text":"","code":"# Load test data from Tabula Muris Senis tms_marrow <- TabulaMurisSenisData::TabulaMurisSenisDroplet(tissues = \"Marrow\") #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> loading from cache #> see ?TabulaMurisSenisData and browseVignettes('TabulaMurisSenisData') for documentation #> loading from cache tms_marrow_counts <- tms_marrow$Marrow@assays@data$counts rownames(tms_marrow_counts) <- rownames(tms_marrow$Marrow) colnames(tms_marrow_counts) <- colnames(tms_marrow$Marrow) tms_marrow_counts <- as(tms_marrow_counts, \"dgCMatrix\")  # Subset age groups and cell types subset_ages <- which(tms_marrow$Marrow$age %in% c(\"3m\", \"30m\")) subset_cell_types <- which(tms_marrow$Marrow$cell_ontology_class %in% c(   \"hematopoietic precursor cell\", \"megakaryocyte-erythroid progenitor cell\",   \"precursor B cell\" )) tms_marrow_counts <- tms_marrow_counts[, intersect(subset_ages, subset_cell_types)]  # Compute the manifold tms_marrow_manifold_neighbor <- compute_manifold(tms_marrow_counts, method = \"neighbor\") #> Starting manifold computation... #> The initial matrix size is 20138 genes and 1980 cells. #> After removing genes with zero counts, the new matrix size is 14812 genes and 1980 cells. #> Estimating the manifold using the neighbor-based method... #> Normalizing layer: counts #> Finding variable features for layer counts #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Ly6e, Bst2, Lgals1, Eef1g, Tspan13, Hspe1, Irf8, Tcf4, Fyb, Ctss  #> \t   Gas5, Selplg, Rnase6, Crip1, Siglech, Dnajc7, Pld4, Tsc22d1, Cnp, Npm1  #> \t   Cd7, Hsp90ab1, Tmsb10, Ly86, Cox6a2, Nme2, Bmyc, Ctsl, Pafah1b3, Ly6d  #> Negative:  Pglyrp1, S100a9, S100a8, Camp, Ngp, 1100001G20Rik, Hp, Lcn2, Cebpe, Chi3l3  #> \t   Anxa1, Clec4a2, Fcnb, Trem3, Dstn, Lyz2, Serpinb1a, Lyz1, Lrg1, Cd63  #> \t   Gsr, 1810033B17Rik, Sepx1, Cd177, Hmgn2, Mgst1, Arhgdib, Ltf, Glrx, Anxa3  #> PC_ 2  #> Positive:  Ptma, Stmn1, Cks1b, Hmgb1, Hist1h2ao, Cks2, Atpif1, Top2a, Cmtm7, Tuba1b  #> \t   H2afx, Birc5, Cdca8, Plac8, Hist1h2ae, Mki67, Rps27l, Spc24, Smc2, Gpx1  #> \t   Hmgb3, Ran, Tpx2, Lmnb1, Cdca3, Ybx1, Igfbp4, Ccna2, Eif5a, Myb  #> Negative:  Ccl5, Gimap4, Cd3d, Ms4a4b, Cd3g, Ltb, Shisa5, AW112010, Gimap3, Thy1  #> \t   Cd2, Lck, Ctsw, Gimap6, Ms4a6b, Cd3e, Skap1, Gimap7, Il2rb, Sh2d1a  #> \t   Xcl1, Lime1, Fam189b, Tmsb10, Klrk1, Arl4c, Txk, Zap70, Cd160, Bcl2  #> PC_ 3  #> Positive:  Ctla2a, Nkg7, AW112010, Ccnd2, Gpr56, Ccl5, Mif, Gimap4, Cd3d, Cd3g  #> \t   Ms4a4b, Rab38, Cd27, Lck, Bcl2, Rps2, Muc13, Lat, Klk8, Ltb  #> \t   Angpt1, Gimap3, Ms4a6b, Nrgn, Thy1, Serpina3g, Pdcd4, Rpl22l1, Gata2, Tspan4  #> Negative:  Grn, Ctsh, Siglech, Pld4, Rnase6, Mpeg1, Lair1, Ctsl, Cybasc3, Unc93b1  #> \t   Ctsb, Cox6a2, Nucb2, Ppfia4, Irf8, Ly86, Upb1, Tcf4, 2210020M01Rik, Ccr9  #> \t   Clec12a, Psap, Ly6d, Pltp, Runx2, Bst2, Spib, Cd300c, Atp1b1, Ccnd1  #> PC_ 4  #> Positive:  Ptma, Actg1, Rps2, Rpl22l1, Ldha, Ybx1, Nop10, Gpi1, Mif, Arhgdib  #> \t   Npm1, Rps15a-ps4, Pgam1, Nme2, Snrpf, Igfbp4, C1qbp, Impdh2, Tpi1, Cd34  #> \t   Gar1, Nhp2, Hspa8, Emb, Set, Cdca7, Pebp1, Cdk4, Hsp90ab1, Srm  #> Negative:  Gypa, Slc4a1, Rhd, Trim10, Tspan33, Beta-s, Tspo2, Snca, Rhag, Epb4.2  #> \t   Cldn13, Alas2, Ctse, Fech, Slc25a37, Isg20, Mgst3, Kel, Car2, Hmbs  #> \t   Hbb-b2, Blvrb, Fam55b, Ermap, Hemgn, Hbq1b, Cpox, Slc43a1, Apol11b, Dhrs11  #> PC_ 5  #> Positive:  Top2a, Tubb5, H2afx, Prc1, Nusap1, Racgap1, Cenpf, Cenpe, Kif11, Smc4  #> \t   Tpx2, Kif22, Kif23, Birc5, Ccna2, Aurkb, Tuba1b, Hist1h2ae, Mis18bp1, Cdca8  #> \t   Ube2s, Nek2, Ube2c, Cdca3, Hmmr, Kif20b, Spc24, Cks1b, Mki67, Cep55  #> Negative:  Sdpr, Pf4, Mpl, Rab27b, Gng11, Itga2b, Treml1, Gp9, Mmrn1, Esam  #> \t   Gp1bb, Gp5, Gucy1a3, Vwf, Fhl1, Rbpms2, Dusp3, Selp, Cttn, Mrvi1  #> \t   Clu, Tbxas1, Arhgap6, Ifitm3, Trpc6, Ptrf, F2rl2, Pbx1, Myct1, Gucy1b3  #> Computing nearest neighbors #> Only one graph name supplied, storing nearest-neighbor graph only #> [1] \"Successfully extracted the nearest neighbors. Estimation procedure is starting.\" #> Finished computing manifold using the neighbor-based method. Time taken: 7.59 seconds.  # Estimate the dispersion parameters tms_marrow_cell_types <- tms_marrow$Marrow$cell_ontology_class[intersect(   subset_ages,   subset_cell_types )] tms_marrow_ages <- tms_marrow$Marrow$age[intersect(subset_ages, subset_cell_types)] tms_marrow_dispersions <- estimate_dispersion(tms_marrow_counts, tms_marrow_manifold_neighbor,   tms_marrow_cell_types, tms_marrow_ages,   model = \"cCV\", ncores = 2, cell.types.cutoff = 10 ) #> Preprocessing the count matrix #> The initial matrix size is 20138 genes and 1980 cells. #> After removing genes with zero counts, the new matrix size is 14812 genes and 1980 cells. #> Calculating normalization factors #> Estimating dispersion parameters for 3m hematopoietic precursor cell #> 14812 genes, 285 cells #> Running SAVER given prior means with 2 worker(s) #> Start time: 2024-09-02 07:48:59.505763 #> Estimating finish time... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:49:30.386553 #> Finished 3778/14812 genes. Approximate finish time: 2024-09-02 07:49:27.196037 #> Finished 7456/14812 genes. Approximate finish time: 2024-09-02 07:49:27.858882 #> Finished 11134/14812 genes. Approximate finish time: 2024-09-02 07:49:27.861341 #> Finished 14812/14812 genes. Approximate finish time: 2024-09-02 07:49:27.80809 #> Done! #> Finish time: 2024-09-02 07:49:27.808594 #> Total time: 28.30269 secs #> Estimating dispersion parameters for 30m hematopoietic precursor cell #> 14812 genes, 524 cells #> Running SAVER given prior means with 2 worker(s) #> Start time: 2024-09-02 07:49:28.599308 #> Estimating finish time... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:50:08.919164 #> Finished 3778/14812 genes. Approximate finish time: 2024-09-02 07:50:09.666858 #> Finished 7456/14812 genes. Approximate finish time: 2024-09-02 07:50:10.177323 #> Finished 11134/14812 genes. Approximate finish time: 2024-09-02 07:50:10.029812 #> Finished 14812/14812 genes. Approximate finish time: 2024-09-02 07:50:10.169994 #> Done! #> Finish time: 2024-09-02 07:50:10.170676 #> Total time: 41.57121 secs #> Estimating dispersion parameters for 3m megakaryocyte-erythroid progenitor cell #> 14812 genes, 133 cells #> Running SAVER given prior means with 2 worker(s) #> Start time: 2024-09-02 07:50:10.516727 #> Estimating finish time... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:50:35.956138 #> Finished 3778/14812 genes. Approximate finish time: 2024-09-02 07:50:40.590781 #> Finished 7456/14812 genes. Approximate finish time: 2024-09-02 07:50:40.246545 #> Finished 11134/14812 genes. Approximate finish time: 2024-09-02 07:50:40.074913 #> Finished 14812/14812 genes. Approximate finish time: 2024-09-02 07:50:39.985882 #> Done! #> Finish time: 2024-09-02 07:50:39.986376 #> Total time: 29.46951 secs #> Estimating dispersion parameters for 30m megakaryocyte-erythroid progenitor cell #> 14812 genes, 616 cells #> Running SAVER given prior means with 2 worker(s) #> Start time: 2024-09-02 07:50:40.950429 #> Estimating finish time... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:51:19.683053 #> Finished 3778/14812 genes. Approximate finish time: 2024-09-02 07:51:23.707048 #> Finished 7456/14812 genes. Approximate finish time: 2024-09-02 07:51:24.069989 #> Finished 11134/14812 genes. Approximate finish time: 2024-09-02 07:51:23.764799 #> Finished 14812/14812 genes. Approximate finish time: 2024-09-02 07:51:23.84575 #> Done! #> Finish time: 2024-09-02 07:51:23.84626 #> Total time: 42.89569 secs #> Estimating dispersion parameters for 3m precursor B cell #> 14812 genes, 259 cells #> Running SAVER given prior means with 2 worker(s) #> Start time: 2024-09-02 07:51:24.275704 #> Estimating finish time... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:51:47.087966 #> Finished 3778/14812 genes. Approximate finish time: 2024-09-02 07:51:49.52827 #> Finished 7456/14812 genes. Approximate finish time: 2024-09-02 07:51:49.257251 #> Finished 11134/14812 genes. Approximate finish time: 2024-09-02 07:51:49.05035 #> Finished 14812/14812 genes. Approximate finish time: 2024-09-02 07:51:49.275609 #> Done! #> Finish time: 2024-09-02 07:51:49.276189 #> Total time: 25.00032 secs #> Estimating dispersion parameters for 30m precursor B cell #> 14812 genes, 163 cells #> Running SAVER given prior means with 2 worker(s) #> Start time: 2024-09-02 07:51:49.639358 #> Estimating finish time... #> Finished 100/14812 genes. Approximate finish time: 2024-09-02 07:52:05.945511 #> Finished 3778/14812 genes. Approximate finish time: 2024-09-02 07:52:10.04973 #> Finished 7456/14812 genes. Approximate finish time: 2024-09-02 07:52:09.828468 #> Finished 11134/14812 genes. Approximate finish time: 2024-09-02 07:52:09.56862 #> Finished 14812/14812 genes. Approximate finish time: 2024-09-02 07:52:09.532427 #> Done! #> Finish time: 2024-09-02 07:52:09.532949 #> Total time: 19.89346 secs"}]
