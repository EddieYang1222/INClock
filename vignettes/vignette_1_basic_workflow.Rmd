---
title: "Vignette 1: Basic workflow of INClock"
author: "Yilin Yang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Vignette Info

This Vignette depicts a basic workflow of INClock that generates dispersion parameters for each cell type / age group. Examples of downstream analyses can be found in other vignettes.

```{r eval=FALSE}
library("INClock")
```

## Prepare the test data

We will use single-cell RNA sequencing data from [Tabula Muris Senis](https://tabula-muris-senis.ds.czbiohub.org/) as our test data. Specifically, it concerns with the bone marrow cells of mouse at different ages. As the original dataset is too large for demonstration, we will only take a subset of its most relevant cell types and age groups, which includes one younger (3 months) and one older (30 months) age groups, as well as several stem cell types, such as hematopoietic precursor cell (HSC). The dataset is loaded with [TabulaMurisSenisData](https://fmicompbio.github.io/TabulaMurisSenisData/), which is already integrated into our package for test purposes.

```{r eval=FALSE}
# Load test data from Tabula Muris Senis
tms_marrow <- TabulaMurisSenisData::TabulaMurisSenisDroplet(tissues = "Marrow")
tms_marrow_counts <- tms_marrow$Marrow@assays@data$counts
rownames(tms_marrow_counts) <- rownames(tms_marrow$Marrow)
colnames(tms_marrow_counts) <- colnames(tms_marrow$Marrow)
tms_marrow_counts <- as(tms_marrow_counts, "dgCMatrix")

# Subset age groups and cell types
subset_ages <- which(tms_marrow$Marrow$age %in% c("3m", "30m"))
subset_cell_types <- which(tms_marrow$Marrow$cell_ontology_class %in% c(
  "hematopoietic precursor cell", "megakaryocyte-erythroid progenitor cell",
  "precursor B cell"
))
tms_marrow_counts <- tms_marrow_counts[, intersect(subset_ages, subset_cell_types)]
```

## Compute the manifold

We can simply call `compute_manifold()` to compute the manifold matrix for our test data. The function only requires one input files:

* Gene expression count matrix (Gene by Cell) (`counts`)

The matrix has to be in either `matrix` or `dgCMatrix` format, as required by dependent packages such as [SAVER](https://mohuangx.github.io/SAVER/) and [Seurat](https://satijalab.org/seurat/).

Before running, we need to specify the method to use, either `'SAVER'` or `'neighbor'`. If `'SAVER'` is selected, then you have the following customizable options:

* Number of CPU cores to use. Default is 1. (`ncores`)

If `'neighbor'` is selected, then you have the following customizable options:

* Number of features for finding variable features. Default is 3000. (`nfeatures`)
* Number of dimensions for finding nearest neighbors. Default is 20. (`dims`)
* Number of neighbors to output. Default is 20. (`neighbors`)

The number of features and dimensions typically don't affect the quality of the manifold much. The number of neighbors used, however, can somewhat affect. To facilitate an optimal selection of number of neighbors, it is recommended to go through Vignette 3. From our previous tests, datasets of sizes less than 100,000 cells typically have an optimal number of neighbors around 20 to 30.

```{r eval=FALSE}
# Compute the manifold with SAVER
tms_marrow_manifold_saver <- compute_manifold(tms_marrow_counts, method = "SAVER")

# Compute the manifold with neighbor-based method
tms_marrow_manifold_neighbor <- compute_manifold(tms_marrow_counts, method = "neighbor")
```
